<!DOCTYPE html>
<html>
<head>
<title>js-model Documentation</title>
<link href="/js-model/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <h1>js-model</h1>

  <p>Source: <a href="http://github.com/benpickles/js-model">github.com/benpickles/js-model</a></p>

  <p>Dependencies:</p>

  <ul>
  <li><a href="http://jquery.com/">jQuery</a></li>
  <li><a href="http://documentcloud.github.com/underscore/">Underscore</a></li>
  </ul>

  <h2>Getting started</h2>

  <p>The first thing to do is to create a model class using the factory <code>Model()</code>:</p>

  <pre><code>var Post = Model("post")</code></pre>

  <p>This allows you to create instances of 'post' models, and also contains an internal collection of all 'posts' which can be used for querying.</p>

  <h2>Manipulating objects (without persistence yet)</h2>

  <p>The next thing you need to do is create and manipulate instances of your new JS model. These actions should be fairly familiar to people who have used ActiveRecord.</p>

  <h3><code>create</code></h3>

  <pre><code>var post = new Post({ foo: "bar" })</code></pre>

  <h3><code>update</code></h3>

  <pre><code>post.update({ foo: "bar" })</code></pre>

  <h3><code>destroy</code></h3>

  <pre><code>post.destroy()</code></pre>

  <p>Attributes are read with the attr method, which works in a similar way to JQuery on the DOM:</p>

  <pre><code>post.attr("foo");         // Getter
post.attr("foo", "bar");  // Setter</code></pre>

  <p>The id of an object is set after persistence, and is accessible via the <code>id()</code> method.</p>

  <h3>Maintaining the state of collections</h3>

  <p>Instances need to be fed back into the model's collection, so that the results are available to "finders". The 2 main methods which handle this are:</p>

  <ul>
  <li>Post.add(post)</li>
  <li>Post.remove(post.id())</li>
  </ul>

  <p>These are called automatically after successful persistence, but can also be called manually.</p>

  <h2>Finding objects</h2>

  <p>Since state is held in the browser, objects need to be queried from our collection in order to be manipulated and used in the UI. This is where js-model is different to several other solutions. It is not a REST-based proxy for the objects on your server, and doesn't rely on constant HTTP requests to gather information. Instead it look up objects in its own cache.</p>

  <p>Different finders are available</p>

  <pre><code>Post.all()</code></pre>

  <p>and</p>

  <pre><code>Post.find(id)</code></pre>

  <p>These are useful for iterating over the collection and finding specific objects, respectively. It is also possible to add custom finders to the collection's prototype (see below).</p>

  <h2>Linking data objects to UI elements</h2>

  <p>js-model allows you to listen to the lifecycle of objects, based on the events they trigger at different points.</p>

  <h3>Collection events</h3>

  <p>It is possible to bind to an event occurring when adding an object to a collection. Eg:</p>

  <pre><code>MyCollection.bind("add", function(new_object) {
  add_object_into_ui(new_object)
})</code></pre>

  <p>and</p>

  <pre><code>MyCollection.bind("remove", function(removed_object) {
  remove_object_from_ui(removed_object)
})</code></pre>

  <h3>Instance events:</h3>

  <p>Parts of your application can be bound to changes which happen to a <strong>specific</strong> instance:</p>

  <pre><code>my_object.bind("update", function() {
  my_ui_elem.text(my_object.attr("name"))
})</code></pre>

  <p>Including when the instance is destroyed:</p>

  <pre><code>my_object.bind("remove", function() {
  my_ui_elem.remove()
})</code></pre>

  <h2>Persistence</h2>

  <p>State can be persisted in a number of ways, including local storage. However, one of the most common uses is via REST to the originating server. js-model comes bundled with an optional REST persistence adaptor.</p>

  <h3>REST/Ajax persistence</h3>

  <p>Setting up persistence for a given model is handled when the class is created:</p>

  <pre><code>var Post = Model("post", {
  persistence: Model.RestPersistence("/posts")
})</code></pre>

  <p>Calling <strong>save</strong> or <strong>destroy</strong> on an object now fires a corresponding REST Request:</p>

  <pre><code>var post = new Post({ foo: "bar" }).save()
// makes a POST request to "/posts"</code></pre>

  <p>A custom callback can be fed into the save method to execute on success or failure:</p>

  <pre><code>post.save(function(success) {
  if (success) {
    alert("yey")
  } else {
    alert("boo")
  }
})</code></pre>

  <p>The default triggered events (mentioned earlier) are generally only called once persistence is successful.</p>

  <h2>Validations</h2>

  <p>It is possible to have local validations to avoid hitting your server unnecessarily.</p>

  <p>To add your own validations you should define a custom <code>validate</code> method that adds error messages to the <code>errors</code> object. <code>valid()</code> is called on save and checks that <code>errors</code> is empty.</p>

  <pre><code>var Post = Model("post", {
  validate: function() {
    if (this.attr("title") != "Bar") {
      this.errors.add("title", "should be Bar")
    }
  }
})

var post = new Post()
post.attr("title", "Foo")

post.valid()                // =&gt; false
post.errors.size()          // =&gt; 1
post.errors.on("title")     // =&gt; ["should be Bar"]
post.errors.all()           // =&gt; { title: ["should be Bar"] }

post.attr("title", "Bar")

post.valid()                // =&gt; true
post.errors.size()          // =&gt; 0
post.errors.on("title")     // =&gt; []
post.errors.all()           // =&gt; {}</code></pre>

  <h2>Adding custom methods</h2>

  <p>Since models are objects, there can be a need to give them custom public methods. There are parts to a js-model which can be extended, and these are akin to instance and class methods on an ORM such as ActiveRecord.</p>

  <h3>Instance methods</h3>

  <p>Instance methods are often used to link objects together in a way which mimics the relationships the data might have in the remote database ('has many' etc). However, they can be pretty much anything. These are defined on the model at class creation time, they are added to the model's <code>prototype</code> overwriting the defaults if necessary.</p>

  <pre><code>var Post = Model("post", {
  foo: function() {
    ...
  }
})

Post.find(3).foo()</code></pre>

  <h3>Collection (Class) methods</h3>

  <p>These are defined by extending the <code>collection</code> method of a model with an altered version of <code>Model.Collection</code>, eg:</p>

  <pre><code>var Post = Model("post", {
  collection: Model.Collection({
    find_by_foo: function(foo) {
      return this.detect(function() {
        return this.attr("foo") == foo;
      });
    }
  })
}

Post.find_by_foo("bar")</code></pre>

  <h2>Triggering custom events</h2>

  <p>You might also want to have custom events on objects, which are also possible:</p>

  <pre><code>post.trigger("turn_blue")</code></pre>

  <p>Which could be linked up to a UI element.</p>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-117680-14");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>